package packagewriter

import (
	"bytes"
	"github.com/WillAbides/go-github-cli/generator/internal"
	"github.com/pkg/errors"
	"go/format"
	"golang.org/x/tools/imports"
	"io/ioutil"
	"os"
	"path/filepath"
	"text/template"
)

var tmpl = template.Must(template.New("").Parse(pkgTemplate))

func WritePackageFiles(basePath string, pkger Packager) error {
	pkg, err := pkger.ToPkg()
	if err != nil {
		return errors.Wrap(err, "failed running ToPkg()")
	}
	if pkg.PackageName == "" {
		return errors.Wrap(err, "packages need names")
	}
	packagePath := filepath.Join(basePath, "services", pkg.PackageName)
	err = os.MkdirAll(packagePath, 0755)
	if err != nil {
		return errors.Wrapf(err, "failed creating directory: %q", packagePath)
	}
	err = writeGoFile(pkg.PackageName+".go", "svcpackage", pkg, packagePath)
	if err != nil {
		return errors.Wrap(err, "failed writing svcpackage template")
	}
	err = writeGoFile("testhelper_test.go", "testhelper", pkg, packagePath)
	return errors.Wrap(err, "failed writing testhelper template")
}

//writeGoFile executes the named template and does the equivalent of `go fmt` and `goimports` on the output
func writeGoFile(filename, templateName string, p interface{}, path string) error {
	var buf bytes.Buffer
	err := tmpl.ExecuteTemplate(&buf, templateName, p)
	if err != nil {
		return errors.Wrap(err, "failed to execute template")
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		return errors.Wrap(err, "failed running format.Source")
	}
	out, err = imports.Process("", out, nil)
	if err != nil {
		return errors.Wrap(err, "failed running imports.Process")
	}
	fl := filepath.Join(path, filename)
	return ioutil.WriteFile(fl, out, 0644)
}

type Packager interface{
	ToPkg() (*internal.Pkg, error)
}

// language=GoTemplate
const pkgTemplate = `
{{define "run_method_arg"}}{{if .IsPtr}}c.to{{.Name}}(k){{else}}c.{{.Name}}{{end}}{{end}}

{{define "run_method_args"}}{{range $index, $element := .Args}}{{if $index}}, {{end}}{{template "run_method_arg" .}}{{end}}{{end}}

{{define "run_method"}}
	{{if .}}
	func (c *{{.StructName}}) Run(k *kong.Context) error {
			ctx := context.Background()
			client, e := buildGithubClient(ctx, c.Token, c.APIBaseURL)
			if e != nil {
				return e
			}
			{{if .HasElement}}element, {{end}}_, err := client.{{.SvcName}}.{{.FuncName}}(ctx, {{template "run_method_args" .}})
			{{if .HasElement}}	if err != nil {
			return err
		}
		return json.NewEncoder(k.Stdout).Encode(element){{else}}	return err{{end}}
	}
	{{end}}
{{end}}

{{define "structtype"}}
	type {{.Name}} struct { {{range .Fields}}
		{{.Name}} {{.Type}} {{if .Tags}}{{printf "%#q" .Tags}} {{end}}{{end}}
	}
	{{template "run_method" .RunMethod}}{{template "tofunc" .ToFunc}}{{range .ChildStructs}}{{template "structtype" .}}{{end}}
{{end}}

{{define "tofunc"}}{{if .}}
	func (t {{.ReceiverName}}) to{{.TargetName}}(k *kong.Context) *{{.TargetType}} {
		val := &{{.TargetType}}{}
		{{if .IncludePointerHelper}}
			isValueSet := func (valueName string) bool {
				if k == nil {
					return false
				}
				for _, flag := range k.Flags() {
					if flag.Name == valueName {
						return flag.Set
					}
				}
				return false
			}
		{{end}}
		{{template "val_setters" .ValSetters}}
		return val
	}
{{end}}{{end}}

{{define "val_setters"}}{{range .}}{{template "val_setter" .}}{{end}}{{end}}

{{define "val_setter"}}{{if .TargetIsPtr}}	if isValueSet("{{.FlagName}}") {
		val.{{.Name}} = &t.{{.Name}}
	}{{else}}	val.{{.Name}} = t.{{.Name}}{{end}}

{{end}}

{{define "svcpackage"}}
	// Code generated by go-github-cli/generator DO NOT EDIT
	package {{$.PackageName}}

	import ( {{range .Imports}}
	   "{{.}}"{{end}}
	)

	var transportWrapper interface {
		SetTransport(t http.RoundTripper)
		http.RoundTripper
	}
	
	func buildGithubClient(ctx context.Context, token, apiBaseURL string) (*github.Client, error) {
		apiBaseURL  = strings.TrimSuffix(apiBaseURL, "/") + "/"
		ts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: token})
		tc := oauth2.NewClient(ctx, ts)
		if transportWrapper != nil {
			transportWrapper.SetTransport(tc.Transport)
			tc.Transport = transportWrapper
		}
		client := github.NewClient(tc)
		baseURL, err := url.Parse(apiBaseURL)
		client.BaseURL = baseURL
		return client, err
	}

	{{range .CmdHelpers}}{{template "structtype" .}}{{end}}
{{end}}

{{define "testhelper"}}
	// Code generated by go-github-cli/generator DO NOT EDIT
	package {{$.PackageName}}

	import (
		"bytes"
		"github.com/alecthomas/kong"
		"github.com/dnaeon/go-vcr/recorder"
		"github.com/stretchr/testify/require"
		"os"
		"path/filepath"
		"testing"
	)
	
	func init() {
		tkn, ok := os.LookupEnv("TESTUSER_TOKEN")
		if !ok {
			tkn = "deadbeef"
		}
		os.Setenv("GITHUB_TOKEN", tkn)
	}
	
	func startVCR(t *testing.T, recPath string) *recorder.Recorder {
		t.Helper()
		var err error
		rec, err := recorder.New(recPath)
		require.Nil(t, err)
		transportWrapper = rec
		return rec
	}
	
	func testCmdLine(t *testing.T, fixtureName string, cmdStruct interface{}, cmdline ...string) (stdout bytes.Buffer, stderr bytes.Buffer, err error) {
		t.Helper()
		rec := startVCR(t, filepath.Join("testdata", "fixtures", fixtureName))
		defer rec.Stop()
		p, e := kong.New(cmdStruct)
		require.Nil(t, e)
		p.Stdout = &stdout
		p.Stderr = &stderr
		k, e := p.Parse(cmdline)
		require.Nil(t, e)
		err = k.Run()
		return
	}
{{end}}

`

