// Code generated by go-github-cli/generator; DO NOT EDIT.

package services

type ReposCmd struct {
	List                                               ReposListCmd                                               `cmd:"" help:"List your repositories"`
	ListForUser                                        ReposListForUserCmd                                        `cmd:"" help:"List user repositories"`
	ListForOrg                                         ReposListForOrgCmd                                         `cmd:"" help:"List organization repositories"`
	ListPublic                                         ReposListPublicCmd                                         `cmd:"" help:"List all public repositories"`
	CreateForAuthenticatedUser                         ReposCreateForAuthenticatedUserCmd                         `cmd:"" help:"Create a new repository for the authenticated user"`
	CreateInOrg                                        ReposCreateInOrgCmd                                        `cmd:"" help:"Create a new repository in this organization"`
	Get                                                ReposGetCmd                                                `cmd:"" help:"Get"`
	Edit                                               ReposEditCmd                                               `cmd:"" help:"Edit"`
	ListTopics                                         ReposListTopicsCmd                                         `cmd:"" help:"List all topics for a repository"`
	ReplaceTopics                                      ReposReplaceTopicsCmd                                      `cmd:"" help:"Replace all topics for a repository"`
	ListContributors                                   ReposListContributorsCmd                                   `cmd:"" help:"List contributors"`
	ListLanguages                                      ReposListLanguagesCmd                                      `cmd:"" help:"List languages"`
	ListTeams                                          ReposListTeamsCmd                                          `cmd:"" help:"List teams"`
	ListTags                                           ReposListTagsCmd                                           `cmd:"" help:"List tags"`
	Delete                                             ReposDeleteCmd                                             `cmd:"" help:"Delete a repository"`
	Transfer                                           ReposTransferCmd                                           `cmd:"" help:"Transfer a repository"`
	ListBranches                                       ReposListBranchesCmd                                       `cmd:"" help:"List branches"`
	GetBranch                                          ReposGetBranchCmd                                          `cmd:"" help:"Get branch"`
	GetBranchProtection                                ReposGetBranchProtectionCmd                                `cmd:"" help:"Get branch protection"`
	RemoveBranchProtection                             ReposRemoveBranchProtectionCmd                             `cmd:"" help:"Remove branch protection"`
	GetProtectedBranchRequiredStatusChecks             ReposGetProtectedBranchRequiredStatusChecksCmd             `cmd:"" help:"Get required status checks of protected branch"`
	UpdateProtectedBranchRequiredStatusChecks          ReposUpdateProtectedBranchRequiredStatusChecksCmd          `cmd:"" help:"Update required status checks of protected branch"`
	RemoveProtectedBranchRequiredStatusChecks          ReposRemoveProtectedBranchRequiredStatusChecksCmd          `cmd:"" help:"Remove required status checks of protected branch"`
	ListProtectedBranchRequiredStatusChecksContexts    ReposListProtectedBranchRequiredStatusChecksContextsCmd    `cmd:"" help:"List required status checks contexts of protected branch"`
	ReplaceProtectedBranchRequiredStatusChecksContexts ReposReplaceProtectedBranchRequiredStatusChecksContextsCmd `cmd:"" help:"Replace required status checks contexts of protected branch"`
	AddProtectedBranchRequiredStatusChecksContexts     ReposAddProtectedBranchRequiredStatusChecksContextsCmd     `cmd:"" help:"Add required status checks contexts of protected branch"`
	RemoveProtectedBranchRequiredStatusChecksContexts  ReposRemoveProtectedBranchRequiredStatusChecksContextsCmd  `cmd:"" help:"Remove required status checks contexts of protected branch"`
	GetProtectedBranchPullRequestReviewEnforcement     ReposGetProtectedBranchPullRequestReviewEnforcementCmd     `cmd:"" help:"Get pull request review enforcement of protected branch"`
	RemoveProtectedBranchPullRequestReviewEnforcement  ReposRemoveProtectedBranchPullRequestReviewEnforcementCmd  `cmd:"" help:"Remove pull request review enforcement of protected branch"`
	GetProtectedBranchRequiredSignatures               ReposGetProtectedBranchRequiredSignaturesCmd               `cmd:"" help:"Get required signatures of protected branch"`
	AddProtectedBranchRequiredSignatures               ReposAddProtectedBranchRequiredSignaturesCmd               `cmd:"" help:"Add required signatures of protected branch"`
	RemoveProtectedBranchRequiredSignatures            ReposRemoveProtectedBranchRequiredSignaturesCmd            `cmd:"" help:"Remove required signatures of protected branch"`
	GetProtectedBranchAdminEnforcement                 ReposGetProtectedBranchAdminEnforcementCmd                 `cmd:"" help:"Get admin enforcement of protected branch"`
	AddProtectedBranchAdminEnforcement                 ReposAddProtectedBranchAdminEnforcementCmd                 `cmd:"" help:"Add admin enforcement of protected branch"`
	RemoveProtectedBranchAdminEnforcement              ReposRemoveProtectedBranchAdminEnforcementCmd              `cmd:"" help:"Remove admin enforcement of protected branch"`
	GetProtectedBranchRestrictions                     ReposGetProtectedBranchRestrictionsCmd                     `cmd:"" help:"Get restrictions of protected branch"`
	RemoveProtectedBranchRestrictions                  ReposRemoveProtectedBranchRestrictionsCmd                  `cmd:"" help:"Remove restrictions of protected branch"`
	ListProtectedBranchTeamRestrictions                ReposListProtectedBranchTeamRestrictionsCmd                `cmd:"" help:"List team restrictions of protected branch"`
	ReplaceProtectedBranchTeamRestrictions             ReposReplaceProtectedBranchTeamRestrictionsCmd             `cmd:"" help:"Replace team restrictions of protected branch"`
	AddProtectedBranchTeamRestrictions                 ReposAddProtectedBranchTeamRestrictionsCmd                 `cmd:"" help:"Add team restrictions of protected branch"`
	RemoveProtectedBranchTeamRestrictions              ReposRemoveProtectedBranchTeamRestrictionsCmd              `cmd:"" help:"Remove team restrictions of protected branch"`
	ListProtectedBranchUserRestrictions                ReposListProtectedBranchUserRestrictionsCmd                `cmd:"" help:"List user restrictions of protected branch"`
	ReplaceProtectedBranchUserRestrictions             ReposReplaceProtectedBranchUserRestrictionsCmd             `cmd:"" help:"Replace user restrictions of protected branch"`
	AddProtectedBranchUserRestrictions                 ReposAddProtectedBranchUserRestrictionsCmd                 `cmd:"" help:"Add user restrictions of protected branch"`
	RemoveProtectedBranchUserRestrictions              ReposRemoveProtectedBranchUserRestrictionsCmd              `cmd:"" help:"Remove user restrictions of protected branch"`
	ListCollaborators                                  ReposListCollaboratorsCmd                                  `cmd:"" help:"List collaborators"`
	CheckCollaborator                                  ReposCheckCollaboratorCmd                                  `cmd:"" help:"Check if a user is a collaborator"`
	GetCollaboratorPermissionLevel                     ReposGetCollaboratorPermissionLevelCmd                     `cmd:"" help:"Review a user's permission level"`
	AddCollaborator                                    ReposAddCollaboratorCmd                                    `cmd:"" help:"Add user as a collaborator"`
	RemoveCollaborator                                 ReposRemoveCollaboratorCmd                                 `cmd:"" help:"Remove user as a collaborator"`
	ListCommitComments                                 ReposListCommitCommentsCmd                                 `cmd:"" help:"List commit comments for a repository"`
	ListCommentsForCommit                              ReposListCommentsForCommitCmd                              `cmd:"" help:"List comments for a single commit"`
	CreateCommitComment                                ReposCreateCommitCommentCmd                                `cmd:"" help:"Create a commit comment"`
	GetCommitComment                                   ReposGetCommitCommentCmd                                   `cmd:"" help:"Get a single commit comment"`
	UpdateCommitComment                                ReposUpdateCommitCommentCmd                                `cmd:"" help:"Update a commit comment"`
	DeleteCommitComment                                ReposDeleteCommitCommentCmd                                `cmd:"" help:"Delete a commit comment"`
	ListCommits                                        ReposListCommitsCmd                                        `cmd:"" help:"List commits on a repository"`
	GetCommit                                          ReposGetCommitCmd                                          `cmd:"" help:"Get a single commit"`
	GetCommitRefSha                                    ReposGetCommitRefShaCmd                                    `cmd:"" help:"Get the SHA-1 of a commit reference"`
	CompareCommits                                     ReposCompareCommitsCmd                                     `cmd:"" help:"Compare two commits"`
	RetrieveCommunityProfileMetrics                    ReposRetrieveCommunityProfileMetricsCmd                    `cmd:"" help:"Retrieve community profile metrics"`
	GetReadme                                          ReposGetReadmeCmd                                          `cmd:"" help:"Get the README"`
	GetContents                                        ReposGetContentsCmd                                        `cmd:"" help:"Get contents"`
	GetArchiveLink                                     ReposGetArchiveLinkCmd                                     `cmd:"" help:"Get archive link"`
	ListDeployKeys                                     ReposListDeployKeysCmd                                     `cmd:"" help:"List deploy keys"`
	GetDeployKey                                       ReposGetDeployKeyCmd                                       `cmd:"" help:"Get a deploy key"`
	AddDeployKey                                       ReposAddDeployKeyCmd                                       `cmd:"" help:"Add a new deploy key"`
	RemoveDeployKey                                    ReposRemoveDeployKeyCmd                                    `cmd:"" help:"Remove a deploy key"`
	ListDeployments                                    ReposListDeploymentsCmd                                    `cmd:"" help:"List deployments"`
	GetDeployment                                      ReposGetDeploymentCmd                                      `cmd:"" help:"Get a single deployment"`
	CreateDeployment                                   ReposCreateDeploymentCmd                                   `cmd:"" help:"Create a deployment"`
	ListDeploymentStatuses                             ReposListDeploymentStatusesCmd                             `cmd:"" help:"List deployment statuses"`
	GetDeploymentStatus                                ReposGetDeploymentStatusCmd                                `cmd:"" help:"Get a single deployment status"`
	CreateDeploymentStatus                             ReposCreateDeploymentStatusCmd                             `cmd:"" help:"Create a deployment status"`
	ListDownloads                                      ReposListDownloadsCmd                                      `cmd:"" help:"List downloads for a repository"`
	GetDownload                                        ReposGetDownloadCmd                                        `cmd:"" help:"Get a single download"`
	DeleteDownload                                     ReposDeleteDownloadCmd                                     `cmd:"" help:"Delete a download"`
	ListForks                                          ReposListForksCmd                                          `cmd:"" help:"List forks"`
	CreateFork                                         ReposCreateForkCmd                                         `cmd:"" help:"Create a fork"`
	ListInvitations                                    ReposListInvitationsCmd                                    `cmd:"" help:"List invitations for a repository"`
	DeleteInvitation                                   ReposDeleteInvitationCmd                                   `cmd:"" help:"Delete a repository invitation"`
	UpdateInvitation                                   ReposUpdateInvitationCmd                                   `cmd:"" help:"Update a repository invitation"`
	ListInvitationsForAuthenticatedUser                ReposListInvitationsForAuthenticatedUserCmd                `cmd:"" help:"List a user's repository invitations"`
	AcceptInvitation                                   ReposAcceptInvitationCmd                                   `cmd:"" help:"Accept a repository invitation"`
	DeclineInvitation                                  ReposDeclineInvitationCmd                                  `cmd:"" help:"Decline a repository invitation"`
	Merge                                              ReposMergeCmd                                              `cmd:"" help:"Perform a merge"`
	GetPages                                           ReposGetPagesCmd                                           `cmd:"" help:"Get information about a Pages site"`
	UpdateInformationAboutPagesSite                    ReposUpdateInformationAboutPagesSiteCmd                    `cmd:"" help:"Update information about a Pages site"`
	RequestPageBuild                                   ReposRequestPageBuildCmd                                   `cmd:"" help:"Request a page build"`
	ListPagesBuilds                                    ReposListPagesBuildsCmd                                    `cmd:"" help:"List Pages builds"`
	GetLatestPagesBuild                                ReposGetLatestPagesBuildCmd                                `cmd:"" help:"Get latest Pages build"`
	GetPagesBuild                                      ReposGetPagesBuildCmd                                      `cmd:"" help:"Get a specific Pages build"`
	ListReleases                                       ReposListReleasesCmd                                       `cmd:"" help:"List releases for a repository"`
	GetRelease                                         ReposGetReleaseCmd                                         `cmd:"" help:"Get a single release"`
	GetLatestRelease                                   ReposGetLatestReleaseCmd                                   `cmd:"" help:"Get the latest release"`
	GetReleaseByTag                                    ReposGetReleaseByTagCmd                                    `cmd:"" help:"Get a release by tag name"`
	CreateRelease                                      ReposCreateReleaseCmd                                      `cmd:"" help:"Create a release"`
	EditRelease                                        ReposEditReleaseCmd                                        `cmd:"" help:"Edit a release"`
	DeleteRelease                                      ReposDeleteReleaseCmd                                      `cmd:"" help:"Delete a release"`
	ListAssetsForRelease                               ReposListAssetsForReleaseCmd                               `cmd:"" help:"List assets for a release"`
	GetReleaseAsset                                    ReposGetReleaseAssetCmd                                    `cmd:"" help:"Get a single release asset"`
	EditReleaseAsset                                   ReposEditReleaseAssetCmd                                   `cmd:"" help:"Edit a release asset"`
	DeleteReleaseAsset                                 ReposDeleteReleaseAssetCmd                                 `cmd:"" help:"Delete a release asset"`
	GetContributorsStats                               ReposGetContributorsStatsCmd                               `cmd:"" help:"Get contributors list with additions, deletions, and commit counts"`
	GetCommitActivityStats                             ReposGetCommitActivityStatsCmd                             `cmd:"" help:"Get the last year of commit activity data"`
	GetCodeFrequencyStats                              ReposGetCodeFrequencyStatsCmd                              `cmd:"" help:"Get the number of additions and deletions per week"`
	GetParticipationStats                              ReposGetParticipationStatsCmd                              `cmd:"" help:"Get the weekly commit count for the repository owner and everyone else"`
	GetPunchCardStats                                  ReposGetPunchCardStatsCmd                                  `cmd:"" help:"Get the number of commits per hour in each day"`
	CreateStatus                                       ReposCreateStatusCmd                                       `cmd:"" help:"Create a status"`
	ListStatusesForRef                                 ReposListStatusesForRefCmd                                 `cmd:"" help:"List statuses for a specific ref"`
	GetCombinedStatusForRef                            ReposGetCombinedStatusForRefCmd                            `cmd:"" help:"Get the combined status for a specific ref"`
	GetTopReferrers                                    ReposGetTopReferrersCmd                                    `cmd:"" help:"List referrers"`
	GetTopPaths                                        ReposGetTopPathsCmd                                        `cmd:"" help:"List paths"`
	GetViews                                           ReposGetViewsCmd                                           `cmd:"" help:"Views"`
	GetClones                                          ReposGetClonesCmd                                          `cmd:"" help:"Clones"`
	ListHooks                                          ReposListHooksCmd                                          `cmd:"" help:"List hooks"`
	GetHook                                            ReposGetHookCmd                                            `cmd:"" help:"Get single hook"`
	TestPushHook                                       ReposTestPushHookCmd                                       `cmd:"" help:"Test a push hook"`
	PingHook                                           ReposPingHookCmd                                           `cmd:"" help:"Ping a hook"`
	DeleteHook                                         ReposDeleteHookCmd                                         `cmd:"" help:"Delete a hook"`
}

type ReposListCmd struct {
	baseCmd
	Visibility  string "name:\"visibility\" help:\"Can be one of `all`, `public`, or `private`.\""
	Affiliation string "name:\"affiliation\" help:\"Comma-separated list of values. Can include:  \n\\* `owner`: Repositories that are owned by the authenticated user.  \n\\* `collaborator`: Repositories that the user has been added to as a collaborator.  \n\\* `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.\""
	Type        string "name:\"type\" help:\"Can be one of `all`, `owner`, `public`, `private`, `member`. Default: `all`  \n  \nWill cause a `422` error if used in the same request as **visibility** or **affiliation**. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.\""
	Sort        string "name:\"sort\" help:\"Can be one of `created`, `updated`, `pushed`, `full_name`.\""
	Direction   string "name:\"direction\" help:\"Can be one of `asc` or `desc`.\""
	PerPage     int64  `name:"per_page" help:"Results per page (max 100)"`
	Page        int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/user/repos"
	c.updateURLQuery("visibility", c.Visibility)
	c.updateURLQuery("affiliation", c.Affiliation)
	c.updateURLQuery("type", c.Type)
	c.updateURLQuery("sort", c.Sort)
	c.updateURLQuery("direction", c.Direction)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposListForUserCmd struct {
	baseCmd
	Username  string `required:"" name:"username"`
	Type      string "name:\"type\" help:\"Can be one of `all`, `owner`, `member`.\""
	Sort      string "name:\"sort\" help:\"Can be one of `created`, `updated`, `pushed`, `full_name`.\""
	Direction string "name:\"direction\" help:\"Can be one of `asc` or `desc`.\""
	PerPage   int64  `name:"per_page" help:"Results per page (max 100)"`
	Page      int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListForUserCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/users/:username/repos"
	c.updateURLPath("username", c.Username)
	c.updateURLQuery("type", c.Type)
	c.updateURLQuery("sort", c.Sort)
	c.updateURLQuery("direction", c.Direction)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposListForOrgCmd struct {
	baseCmd
	Org     string `required:"" name:"org"`
	Type    string "name:\"type\" help:\"Can be one of `all`, `public`, `private`, `forks`, `sources`, `member`.\""
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListForOrgCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/orgs/:org/repos"
	c.updateURLPath("org", c.Org)
	c.updateURLQuery("type", c.Type)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposListPublicCmd struct {
	baseCmd
	Since   string `name:"since" help:"The integer ID of the last Repository that you've seen."`
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListPublicCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repositories"
	c.updateURLQuery("since", c.Since)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposCreateForAuthenticatedUserCmd struct {
	baseCmd
	Name              string `required:"" name:"name" help:"The name of the repository."`
	Description       string `name:"description" help:"A short description of the repository."`
	Homepage          string `name:"homepage" help:"A URL with more information about the repository."`
	Private           bool   "name:\"private\" help:\"Either `true` to create a private repository or `false` to create a public one. Creating private repositories requires a paid GitHub account.\""
	HasIssues         bool   "name:\"has_issues\" help:\"Either `true` to enable issues for this repository or `false` to disable them.\""
	HasProjects       bool   "name:\"has_projects\" help:\"Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.\""
	HasWiki           bool   "name:\"has_wiki\" help:\"Either `true` to enable the wiki for this repository or `false` to disable it.\""
	TeamId            int64  `name:"team_id" help:"The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization."`
	AutoInit          bool   "name:\"auto_init\" help:\"Pass `true` to create an initial commit with empty README.\""
	GitignoreTemplate string `name:"gitignore_template" help:"Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, 'Haskell'."`
	LicenseTemplate   string "name:\"license_template\" help:\"Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://help.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, 'mit' or 'mpl-2.0'.\""
	AllowSquashMerge  bool   "name:\"allow_squash_merge\" help:\"Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.\""
	AllowMergeCommit  bool   "name:\"allow_merge_commit\" help:\"Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.\""
	AllowRebaseMerge  bool   "name:\"allow_rebase_merge\" help:\"Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.\""
}

func (c *ReposCreateForAuthenticatedUserCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/user/repos"
	c.updateBody("name", c.Name)
	c.updateBody("description", c.Description)
	c.updateBody("homepage", c.Homepage)
	c.updateBody("private", c.Private)
	c.updateBody("has_issues", c.HasIssues)
	c.updateBody("has_projects", c.HasProjects)
	c.updateBody("has_wiki", c.HasWiki)
	c.updateBody("team_id", c.TeamId)
	c.updateBody("auto_init", c.AutoInit)
	c.updateBody("gitignore_template", c.GitignoreTemplate)
	c.updateBody("license_template", c.LicenseTemplate)
	c.updateBody("allow_squash_merge", c.AllowSquashMerge)
	c.updateBody("allow_merge_commit", c.AllowMergeCommit)
	c.updateBody("allow_rebase_merge", c.AllowRebaseMerge)
	return c.doRequest("POST")
}

type ReposCreateInOrgCmd struct {
	baseCmd
	Org               string `required:"" name:"org"`
	Name              string `required:"" name:"name" help:"The name of the repository."`
	Description       string `name:"description" help:"A short description of the repository."`
	Homepage          string `name:"homepage" help:"A URL with more information about the repository."`
	Private           bool   "name:\"private\" help:\"Either `true` to create a private repository or `false` to create a public one. Creating private repositories requires a paid GitHub account.\""
	HasIssues         bool   "name:\"has_issues\" help:\"Either `true` to enable issues for this repository or `false` to disable them.\""
	HasProjects       bool   "name:\"has_projects\" help:\"Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.\""
	HasWiki           bool   "name:\"has_wiki\" help:\"Either `true` to enable the wiki for this repository or `false` to disable it.\""
	TeamId            int64  `name:"team_id" help:"The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization."`
	AutoInit          bool   "name:\"auto_init\" help:\"Pass `true` to create an initial commit with empty README.\""
	GitignoreTemplate string `name:"gitignore_template" help:"Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, 'Haskell'."`
	LicenseTemplate   string "name:\"license_template\" help:\"Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://help.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, 'mit' or 'mpl-2.0'.\""
	AllowSquashMerge  bool   "name:\"allow_squash_merge\" help:\"Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.\""
	AllowMergeCommit  bool   "name:\"allow_merge_commit\" help:\"Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.\""
	AllowRebaseMerge  bool   "name:\"allow_rebase_merge\" help:\"Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.\""
}

func (c *ReposCreateInOrgCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/orgs/:org/repos"
	c.updateURLPath("org", c.Org)
	c.updateBody("name", c.Name)
	c.updateBody("description", c.Description)
	c.updateBody("homepage", c.Homepage)
	c.updateBody("private", c.Private)
	c.updateBody("has_issues", c.HasIssues)
	c.updateBody("has_projects", c.HasProjects)
	c.updateBody("has_wiki", c.HasWiki)
	c.updateBody("team_id", c.TeamId)
	c.updateBody("auto_init", c.AutoInit)
	c.updateBody("gitignore_template", c.GitignoreTemplate)
	c.updateBody("license_template", c.LicenseTemplate)
	c.updateBody("allow_squash_merge", c.AllowSquashMerge)
	c.updateBody("allow_merge_commit", c.AllowMergeCommit)
	c.updateBody("allow_rebase_merge", c.AllowRebaseMerge)
	return c.doRequest("POST")
}

type ReposGetCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposGetCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposEditCmd struct {
	baseCmd
	Owner            string `required:"" name:"owner"`
	Repo             string `required:"" name:"repo"`
	Name             string `required:"" name:"name" help:"The name of the repository."`
	Description      string `name:"description" help:"A short description of the repository."`
	Homepage         string `name:"homepage" help:"A URL with more information about the repository."`
	Private          bool   "name:\"private\" help:\"Either `true` to make the repository private or `false` to make it public. Creating private repositories requires a paid GitHub account. Default: `false`.  \n**Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private. **Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.\""
	HasIssues        bool   "name:\"has_issues\" help:\"Either `true` to enable issues for this repository or `false` to disable them.\""
	HasProjects      bool   "name:\"has_projects\" help:\"Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.\""
	HasWiki          bool   "name:\"has_wiki\" help:\"Either `true` to enable the wiki for this repository or `false` to disable it.\""
	DefaultBranch    string `name:"default_branch" help:"Updates the default branch for this repository."`
	AllowSquashMerge bool   "name:\"allow_squash_merge\" help:\"Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.\""
	AllowMergeCommit bool   "name:\"allow_merge_commit\" help:\"Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.\""
	AllowRebaseMerge bool   "name:\"allow_rebase_merge\" help:\"Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.\""
	Archived         bool   "name:\"archived\" help:\"`true` to archive this repository. **Note**: You cannot unarchive repositories through the API.\""
}

func (c *ReposEditCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateBody("name", c.Name)
	c.updateBody("description", c.Description)
	c.updateBody("homepage", c.Homepage)
	c.updateBody("private", c.Private)
	c.updateBody("has_issues", c.HasIssues)
	c.updateBody("has_projects", c.HasProjects)
	c.updateBody("has_wiki", c.HasWiki)
	c.updateBody("default_branch", c.DefaultBranch)
	c.updateBody("allow_squash_merge", c.AllowSquashMerge)
	c.updateBody("allow_merge_commit", c.AllowMergeCommit)
	c.updateBody("allow_rebase_merge", c.AllowRebaseMerge)
	c.updateBody("archived", c.Archived)
	return c.doRequest("PATCH")
}

type ReposListTopicsCmd struct {
	baseCmd
	Mercy bool   "name:\"mercy-preview\" help:\"**Note:** The `topics` property for repositories on GitHub is currently available for developers to preview. To view the `topics` property in calls that return repository results, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.mercy-preview+json\n\n```\""
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposListTopicsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/topics"
	c.updatePreview("mercy", c.Mercy)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposReplaceTopicsCmd struct {
	baseCmd
	Mercy bool     "name:\"mercy-preview\" help:\"**Note:** The `topics` property for repositories on GitHub is currently available for developers to preview. To view the `topics` property in calls that return repository results, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.mercy-preview+json\n\n```\""
	Owner string   `required:"" name:"owner"`
	Repo  string   `required:"" name:"repo"`
	Names []string "required:\"\" name:\"names\" help:\"An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository.\""
}

func (c *ReposReplaceTopicsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/topics"
	c.updatePreview("mercy", c.Mercy)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateBody("names", c.Names)
	return c.doRequest("PUT")
}

type ReposListContributorsCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	Anon    string "name:\"anon\" help:\"Set to `1` or `true` to include anonymous contributors in results.\""
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListContributorsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/contributors"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("anon", c.Anon)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposListLanguagesCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposListLanguagesCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/languages"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposListTeamsCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListTeamsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/teams"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposListTagsCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListTagsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/tags"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposDeleteCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposDeleteCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("DELETE")
}

type ReposTransferCmd struct {
	baseCmd
	Nightshade bool    "name:\"nightshade-preview\" required:\"\" help:\"**Note:** The [Repository Transfer API](/changes/2017-11-09-repository-transfer-api-preview) is currently available for developers to preview. To access the API, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.nightshade-preview+json\n\n```\""
	Owner      string  `required:"" name:"owner"`
	Repo       string  `required:"" name:"repo"`
	NewOwner   string  `name:"new_owner" help:"**Required:** The username or organization name the repository will be transferred to."`
	TeamIds    []int64 `name:"team_ids" help:"ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories."`
}

func (c *ReposTransferCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/transfer"
	c.updatePreview("nightshade", c.Nightshade)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateBody("new_owner", c.NewOwner)
	c.updateBody("team_ids", c.TeamIds)
	return c.doRequest("POST")
}

type ReposListBranchesCmd struct {
	baseCmd
	Owner     string `required:"" name:"owner"`
	Repo      string `required:"" name:"repo"`
	Protected bool   "name:\"protected\" help:\"Setting to `true` returns only protected branches.\""
	PerPage   int64  `name:"per_page" help:"Results per page (max 100)"`
	Page      int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListBranchesCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("protected", c.Protected)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposGetBranchCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposGetBranchCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("GET")
}

type ReposGetBranchProtectionCmd struct {
	baseCmd
	LukeCage bool   "name:\"luke-cage-preview\" help:\"**Note:** The Protected Branches API now has a setting for requiring a specified number of approving pull request reviews before merging. This feature is currently available for developers to preview. See the [blog post](/changes/2018-03-16-protected-branches-required-approving-reviews) for full details. To access the API during the preview period, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.luke-cage-preview+json\n\n```\""
	Owner    string `required:"" name:"owner"`
	Repo     string `required:"" name:"repo"`
	Branch   string `required:"" name:"branch"`
}

func (c *ReposGetBranchProtectionCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection"
	c.updatePreview("luke-cage", c.LukeCage)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("GET")
}

type ReposRemoveBranchProtectionCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposRemoveBranchProtectionCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("DELETE")
}

type ReposGetProtectedBranchRequiredStatusChecksCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposGetProtectedBranchRequiredStatusChecksCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/required_status_checks"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("GET")
}

type ReposUpdateProtectedBranchRequiredStatusChecksCmd struct {
	baseCmd
	Owner    string   `required:"" name:"owner"`
	Repo     string   `required:"" name:"repo"`
	Branch   string   `required:"" name:"branch"`
	Strict   bool     `name:"strict" help:"Require branches to be up to date before merging."`
	Contexts []string `name:"contexts" help:"The list of status checks to require in order to merge into this branch"`
}

func (c *ReposUpdateProtectedBranchRequiredStatusChecksCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/required_status_checks"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	c.updateBody("strict", c.Strict)
	c.updateBody("contexts", c.Contexts)
	return c.doRequest("PATCH")
}

type ReposRemoveProtectedBranchRequiredStatusChecksCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposRemoveProtectedBranchRequiredStatusChecksCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/required_status_checks"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("DELETE")
}

type ReposListProtectedBranchRequiredStatusChecksContextsCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposListProtectedBranchRequiredStatusChecksContextsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("GET")
}

type ReposReplaceProtectedBranchRequiredStatusChecksContextsCmd struct {
	baseCmd
	Owner    string   `required:"" name:"owner"`
	Repo     string   `required:"" name:"repo"`
	Branch   string   `required:"" name:"branch"`
	Contexts []string `required:"" name:"contexts"`
}

func (c *ReposReplaceProtectedBranchRequiredStatusChecksContextsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	c.updateBody("contexts", c.Contexts)
	return c.doRequest("PUT")
}

type ReposAddProtectedBranchRequiredStatusChecksContextsCmd struct {
	baseCmd
	Owner    string   `required:"" name:"owner"`
	Repo     string   `required:"" name:"repo"`
	Branch   string   `required:"" name:"branch"`
	Contexts []string `required:"" name:"contexts"`
}

func (c *ReposAddProtectedBranchRequiredStatusChecksContextsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	c.updateBody("contexts", c.Contexts)
	return c.doRequest("POST")
}

type ReposRemoveProtectedBranchRequiredStatusChecksContextsCmd struct {
	baseCmd
	Owner    string   `required:"" name:"owner"`
	Repo     string   `required:"" name:"repo"`
	Branch   string   `required:"" name:"branch"`
	Contexts []string `required:"" name:"contexts"`
}

func (c *ReposRemoveProtectedBranchRequiredStatusChecksContextsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	c.updateBody("contexts", c.Contexts)
	return c.doRequest("DELETE")
}

type ReposGetProtectedBranchPullRequestReviewEnforcementCmd struct {
	baseCmd
	LukeCage bool   "name:\"luke-cage-preview\" help:\"**Note:** The Protected Branches API now has a setting for requiring a specified number of approving pull request reviews before merging. This feature is currently available for developers to preview. See the [blog post](/changes/2018-03-16-protected-branches-required-approving-reviews) for full details. To access the API during the preview period, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.luke-cage-preview+json\n\n```\""
	Owner    string `required:"" name:"owner"`
	Repo     string `required:"" name:"repo"`
	Branch   string `required:"" name:"branch"`
}

func (c *ReposGetProtectedBranchPullRequestReviewEnforcementCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews"
	c.updatePreview("luke-cage", c.LukeCage)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("GET")
}

type ReposRemoveProtectedBranchPullRequestReviewEnforcementCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposRemoveProtectedBranchPullRequestReviewEnforcementCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("DELETE")
}

type ReposGetProtectedBranchRequiredSignaturesCmd struct {
	baseCmd
	Zzzax  bool   "name:\"zzzax-preview\" required:\"\" help:\"**Note:** Protected Branches API can now manage a setting for requiring signed commits. This feature is currently available for developers to preview. See the [blog post](/changes/2018-02-22-protected-branches-required-signatures) for full details. To access the API during the preview period, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.zzzax-preview+json\n\n```\""
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposGetProtectedBranchRequiredSignaturesCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/required_signatures"
	c.updatePreview("zzzax", c.Zzzax)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("GET")
}

type ReposAddProtectedBranchRequiredSignaturesCmd struct {
	baseCmd
	Zzzax  bool   "name:\"zzzax-preview\" required:\"\" help:\"**Note:** Protected Branches API can now manage a setting for requiring signed commits. This feature is currently available for developers to preview. See the [blog post](/changes/2018-02-22-protected-branches-required-signatures) for full details. To access the API during the preview period, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.zzzax-preview+json\n\n```\""
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposAddProtectedBranchRequiredSignaturesCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/required_signatures"
	c.updatePreview("zzzax", c.Zzzax)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("POST")
}

type ReposRemoveProtectedBranchRequiredSignaturesCmd struct {
	baseCmd
	Zzzax  bool   "name:\"zzzax-preview\" required:\"\" help:\"**Note:** Protected Branches API can now manage a setting for requiring signed commits. This feature is currently available for developers to preview. See the [blog post](/changes/2018-02-22-protected-branches-required-signatures) for full details. To access the API during the preview period, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.zzzax-preview+json\n\n```\""
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposRemoveProtectedBranchRequiredSignaturesCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/required_signatures"
	c.updatePreview("zzzax", c.Zzzax)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("DELETE")
}

type ReposGetProtectedBranchAdminEnforcementCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposGetProtectedBranchAdminEnforcementCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/enforce_admins"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("GET")
}

type ReposAddProtectedBranchAdminEnforcementCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposAddProtectedBranchAdminEnforcementCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/enforce_admins"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("POST")
}

type ReposRemoveProtectedBranchAdminEnforcementCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposRemoveProtectedBranchAdminEnforcementCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/enforce_admins"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("DELETE")
}

type ReposGetProtectedBranchRestrictionsCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposGetProtectedBranchRestrictionsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/restrictions"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("GET")
}

type ReposRemoveProtectedBranchRestrictionsCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposRemoveProtectedBranchRestrictionsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/restrictions"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("DELETE")
}

type ReposListProtectedBranchTeamRestrictionsCmd struct {
	baseCmd
	Hellcat bool   "name:\"hellcat-preview\" help:\"**Note:** The Nested Teams API is currently available for developers to preview. See the [blog post](/changes/2017-08-30-preview-nested-teams) for full details. To access the API, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.hellcat-preview+json\n\n```\""
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	Branch  string `required:"" name:"branch"`
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListProtectedBranchTeamRestrictionsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams"
	c.updatePreview("hellcat", c.Hellcat)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposReplaceProtectedBranchTeamRestrictionsCmd struct {
	baseCmd
	Hellcat bool     "name:\"hellcat-preview\" help:\"**Note:** The Nested Teams API is currently available for developers to preview. See the [blog post](/changes/2017-08-30-preview-nested-teams) for full details. To access the API, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.hellcat-preview+json\n\n```\""
	Owner   string   `required:"" name:"owner"`
	Repo    string   `required:"" name:"repo"`
	Branch  string   `required:"" name:"branch"`
	Teams   []string `required:"" name:"teams"`
}

func (c *ReposReplaceProtectedBranchTeamRestrictionsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams"
	c.updatePreview("hellcat", c.Hellcat)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	c.updateBody("teams", c.Teams)
	return c.doRequest("PUT")
}

type ReposAddProtectedBranchTeamRestrictionsCmd struct {
	baseCmd
	Hellcat bool     "name:\"hellcat-preview\" help:\"**Note:** The Nested Teams API is currently available for developers to preview. See the [blog post](/changes/2017-08-30-preview-nested-teams) for full details. To access the API, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.hellcat-preview+json\n\n```\""
	Owner   string   `required:"" name:"owner"`
	Repo    string   `required:"" name:"repo"`
	Branch  string   `required:"" name:"branch"`
	Teams   []string `required:"" name:"teams"`
}

func (c *ReposAddProtectedBranchTeamRestrictionsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams"
	c.updatePreview("hellcat", c.Hellcat)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	c.updateBody("teams", c.Teams)
	return c.doRequest("POST")
}

type ReposRemoveProtectedBranchTeamRestrictionsCmd struct {
	baseCmd
	Hellcat bool     "name:\"hellcat-preview\" help:\"**Note:** The Nested Teams API is currently available for developers to preview. See the [blog post](/changes/2017-08-30-preview-nested-teams) for full details. To access the API, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.hellcat-preview+json\n\n```\""
	Owner   string   `required:"" name:"owner"`
	Repo    string   `required:"" name:"repo"`
	Branch  string   `required:"" name:"branch"`
	Teams   []string `required:"" name:"teams"`
}

func (c *ReposRemoveProtectedBranchTeamRestrictionsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams"
	c.updatePreview("hellcat", c.Hellcat)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	c.updateBody("teams", c.Teams)
	return c.doRequest("DELETE")
}

type ReposListProtectedBranchUserRestrictionsCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	Branch string `required:"" name:"branch"`
}

func (c *ReposListProtectedBranchUserRestrictionsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/restrictions/users"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	return c.doRequest("GET")
}

type ReposReplaceProtectedBranchUserRestrictionsCmd struct {
	baseCmd
	Owner  string   `required:"" name:"owner"`
	Repo   string   `required:"" name:"repo"`
	Branch string   `required:"" name:"branch"`
	Users  []string `required:"" name:"users"`
}

func (c *ReposReplaceProtectedBranchUserRestrictionsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/restrictions/users"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	c.updateBody("users", c.Users)
	return c.doRequest("PUT")
}

type ReposAddProtectedBranchUserRestrictionsCmd struct {
	baseCmd
	Owner  string   `required:"" name:"owner"`
	Repo   string   `required:"" name:"repo"`
	Branch string   `required:"" name:"branch"`
	Users  []string `required:"" name:"users"`
}

func (c *ReposAddProtectedBranchUserRestrictionsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/restrictions/users"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	c.updateBody("users", c.Users)
	return c.doRequest("POST")
}

type ReposRemoveProtectedBranchUserRestrictionsCmd struct {
	baseCmd
	Owner  string   `required:"" name:"owner"`
	Repo   string   `required:"" name:"repo"`
	Branch string   `required:"" name:"branch"`
	Users  []string `required:"" name:"users"`
}

func (c *ReposRemoveProtectedBranchUserRestrictionsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/branches/:branch/protection/restrictions/users"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("branch", c.Branch)
	c.updateBody("users", c.Users)
	return c.doRequest("DELETE")
}

type ReposListCollaboratorsCmd struct {
	baseCmd
	Hellcat     bool   "name:\"hellcat-preview\" help:\"**Note:** The Nested Teams API is currently available for developers to preview. See the [blog post](/changes/2017-08-30-preview-nested-teams) for full details. To access the API, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.hellcat-preview+json\n\n```\""
	Owner       string `required:"" name:"owner"`
	Repo        string `required:"" name:"repo"`
	Affiliation string "name:\"affiliation\" help:\"Filter collaborators returned by their affiliation. Can be one of:  \n\\* `outside`: All outside collaborators of an organization-owned repository.  \n\\* `direct`: All collaborators with permissions to an organization-owned repository, regardless of organization membership status.  \n\\* `all`: All collaborators the authenticated user can see.\""
	PerPage     int64  `name:"per_page" help:"Results per page (max 100)"`
	Page        int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListCollaboratorsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/collaborators"
	c.updatePreview("hellcat", c.Hellcat)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("affiliation", c.Affiliation)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposCheckCollaboratorCmd struct {
	baseCmd
	Hellcat  bool   "name:\"hellcat-preview\" help:\"**Note:** The Nested Teams API is currently available for developers to preview. See the [blog post](/changes/2017-08-30-preview-nested-teams) for full details. To access the API, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.hellcat-preview+json\n\n```\""
	Owner    string `required:"" name:"owner"`
	Repo     string `required:"" name:"repo"`
	Username string `required:"" name:"username"`
}

func (c *ReposCheckCollaboratorCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/collaborators/:username"
	c.updatePreview("hellcat", c.Hellcat)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("username", c.Username)
	return c.doRequest("GET")
}

type ReposGetCollaboratorPermissionLevelCmd struct {
	baseCmd
	Owner    string `required:"" name:"owner"`
	Repo     string `required:"" name:"repo"`
	Username string `required:"" name:"username"`
}

func (c *ReposGetCollaboratorPermissionLevelCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/collaborators/:username/permission"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("username", c.Username)
	return c.doRequest("GET")
}

type ReposAddCollaboratorCmd struct {
	baseCmd
	Owner      string `required:"" name:"owner"`
	Repo       string `required:"" name:"repo"`
	Username   string `required:"" name:"username"`
	Permission string "name:\"permission\" help:\"The permission to grant the collaborator. **Only valid on organization-owned repositories.** Can be one of:  \n\\* `pull` - can pull, but not push to or administer this repository.  \n\\* `push` - can pull and push, but not administer this repository.  \n\\* `admin` - can pull, push and administer this repository.\""
}

func (c *ReposAddCollaboratorCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/collaborators/:username"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("username", c.Username)
	c.updateBody("permission", c.Permission)
	return c.doRequest("PUT")
}

type ReposRemoveCollaboratorCmd struct {
	baseCmd
	Owner    string `required:"" name:"owner"`
	Repo     string `required:"" name:"repo"`
	Username string `required:"" name:"username"`
}

func (c *ReposRemoveCollaboratorCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/collaborators/:username"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("username", c.Username)
	return c.doRequest("DELETE")
}

type ReposListCommitCommentsCmd struct {
	baseCmd
	SquirrelGirl bool   "name:\"squirrel-girl-preview\" help:\"An additional `reactions` object in the commit comment payload is currently available for developers to preview. During the preview period, the APIs may change without advance notice. Please see the [blog post](/changes/2016-05-12-reactions-api-preview) for full details.\n\nTo access the API you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\n  application/vnd.github.squirrel-girl-preview\n\n```\n\nThe `reactions` key will have the following payload where `url` can be used to construct the API location for [listing and creating](/v3/reactions) reactions.\""
	Owner        string `required:"" name:"owner"`
	Repo         string `required:"" name:"repo"`
	PerPage      int64  `name:"per_page" help:"Results per page (max 100)"`
	Page         int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListCommitCommentsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/comments"
	c.updatePreview("squirrel-girl", c.SquirrelGirl)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposListCommentsForCommitCmd struct {
	baseCmd
	SquirrelGirl bool   "name:\"squirrel-girl-preview\" help:\"An additional `reactions` object in the commit comment payload is currently available for developers to preview. During the preview period, the APIs may change without advance notice. Please see the [blog post](/changes/2016-05-12-reactions-api-preview) for full details.\n\nTo access the API you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\n  application/vnd.github.squirrel-girl-preview\n\n```\n\nThe `reactions` key will have the following payload where `url` can be used to construct the API location for [listing and creating](/v3/reactions) reactions.\""
	Owner        string `required:"" name:"owner"`
	Repo         string `required:"" name:"repo"`
	Ref          string `required:"" name:"ref"`
	PerPage      int64  `name:"per_page" help:"Results per page (max 100)"`
	Page         int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListCommentsForCommitCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/commits/:ref/comments"
	c.updatePreview("squirrel-girl", c.SquirrelGirl)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("ref", c.Ref)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposCreateCommitCommentCmd struct {
	baseCmd
	Owner    string `required:"" name:"owner"`
	Repo     string `required:"" name:"repo"`
	Sha      string `required:"" name:"sha"`
	Body     string `required:"" name:"body" help:"The contents of the comment."`
	Path     string `name:"path" help:"Relative path of the file to comment on."`
	Position int64  `name:"position" help:"Line index in the diff to comment on."`
	Line     int64  `name:"line" help:"**Deprecated**. Use **position** parameter instead. Line number in the file to comment on."`
}

func (c *ReposCreateCommitCommentCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/commits/:sha/comments"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("sha", c.Sha)
	c.updateBody("body", c.Body)
	c.updateBody("path", c.Path)
	c.updateBody("position", c.Position)
	c.updateBody("line", c.Line)
	return c.doRequest("POST")
}

type ReposGetCommitCommentCmd struct {
	baseCmd
	SquirrelGirl bool   "name:\"squirrel-girl-preview\" help:\"An additional `reactions` object in the commit comment payload is currently available for developers to preview. During the preview period, the APIs may change without advance notice. Please see the [blog post](/changes/2016-05-12-reactions-api-preview) for full details.\n\nTo access the API you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\n  application/vnd.github.squirrel-girl-preview\n\n```\n\nThe `reactions` key will have the following payload where `url` can be used to construct the API location for [listing and creating](/v3/reactions) reactions.\""
	Owner        string `required:"" name:"owner"`
	Repo         string `required:"" name:"repo"`
	CommentId    int64  `required:"" name:"comment_id"`
}

func (c *ReposGetCommitCommentCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/comments/:comment_id"
	c.updatePreview("squirrel-girl", c.SquirrelGirl)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("comment_id", c.CommentId)
	return c.doRequest("GET")
}

type ReposUpdateCommitCommentCmd struct {
	baseCmd
	Owner     string `required:"" name:"owner"`
	Repo      string `required:"" name:"repo"`
	CommentId int64  `required:"" name:"comment_id"`
	Body      string `required:"" name:"body" help:"The contents of the comment"`
}

func (c *ReposUpdateCommitCommentCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/comments/:comment_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("comment_id", c.CommentId)
	c.updateBody("body", c.Body)
	return c.doRequest("PATCH")
}

type ReposDeleteCommitCommentCmd struct {
	baseCmd
	Owner     string `required:"" name:"owner"`
	Repo      string `required:"" name:"repo"`
	CommentId int64  `required:"" name:"comment_id"`
}

func (c *ReposDeleteCommitCommentCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/comments/:comment_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("comment_id", c.CommentId)
	return c.doRequest("DELETE")
}

type ReposListCommitsCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	Sha     string `name:"sha" help:"SHA or branch to start listing commits from."`
	Path    string `name:"path" help:"Only commits containing this file path will be returned."`
	Author  string `name:"author" help:"GitHub login or email address by which to filter by commit author."`
	Since   string "name:\"since\" help:\"Only commits after this date will be returned. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\""
	Until   string "name:\"until\" help:\"Only commits before this date will be returned. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.\""
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListCommitsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/commits"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("sha", c.Sha)
	c.updateURLQuery("path", c.Path)
	c.updateURLQuery("author", c.Author)
	c.updateURLQuery("since", c.Since)
	c.updateURLQuery("until", c.Until)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposGetCommitCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
	Sha   string `required:"" name:"sha"`
}

func (c *ReposGetCommitCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/commits/:sha"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("sha", c.Sha)
	return c.doRequest("GET")
}

type ReposGetCommitRefShaCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
	Ref   string `required:"" name:"ref"`
}

func (c *ReposGetCommitRefShaCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/commits/:ref"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("ref", c.Ref)
	return c.doRequest("GET")
}

type ReposCompareCommitsCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
	Base  string `required:"" name:"base"`
	Head  string `required:"" name:"head"`
}

func (c *ReposCompareCommitsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/compare/:base...:head"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("base", c.Base)
	c.updateURLPath("head", c.Head)
	return c.doRequest("GET")
}

type ReposRetrieveCommunityProfileMetricsCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposRetrieveCommunityProfileMetricsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/community/profile"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposGetReadmeCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
	Ref   string `name:"ref" help:"The name of the commit/branch/tag."`
}

func (c *ReposGetReadmeCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/readme"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("ref", c.Ref)
	return c.doRequest("GET")
}

type ReposGetContentsCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
	Path  string `required:"" name:"path" help:"The content path."`
	Ref   string `name:"ref" help:"The name of the commit/branch/tag."`
}

func (c *ReposGetContentsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/contents/:path"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("path", c.Path)
	c.updateURLQuery("ref", c.Ref)
	return c.doRequest("GET")
}

type ReposGetArchiveLinkCmd struct {
	baseCmd
	Owner         string `required:"" name:"owner"`
	Repo          string `required:"" name:"repo"`
	ArchiveFormat string "required:\"\" name:\"archive_format\" help:\"Can be either `tarball` or `zipball`.\""
	Ref           string `required:"" name:"ref" help:"A valid Git reference."`
}

func (c *ReposGetArchiveLinkCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/:archive_format/:ref"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("archive_format", c.ArchiveFormat)
	c.updateURLPath("ref", c.Ref)
	return c.doRequest("GET")
}

type ReposListDeployKeysCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListDeployKeysCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/keys"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposGetDeployKeyCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
	KeyId int64  `required:"" name:"key_id"`
}

func (c *ReposGetDeployKeyCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/keys/:key_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("key_id", c.KeyId)
	return c.doRequest("GET")
}

type ReposAddDeployKeyCmd struct {
	baseCmd
	Owner    string `required:"" name:"owner"`
	Repo     string `required:"" name:"repo"`
	Title    string `name:"title" help:"A name for the key."`
	Key      string `required:"" name:"key" help:"The contents of the key."`
	ReadOnly bool   "name:\"read_only\" help:\"If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.  \n  \nDeploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see '[Repository permission levels for an organization](https://help.github.com/articles/repository-permission-levels-for-an-organization/)' and '[Permission levels for a user account repository](https://help.github.com/articles/permission-levels-for-a-user-account-repository/).'\""
}

func (c *ReposAddDeployKeyCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/keys"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateBody("title", c.Title)
	c.updateBody("key", c.Key)
	c.updateBody("read_only", c.ReadOnly)
	return c.doRequest("POST")
}

type ReposRemoveDeployKeyCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
	KeyId int64  `required:"" name:"key_id"`
}

func (c *ReposRemoveDeployKeyCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/keys/:key_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("key_id", c.KeyId)
	return c.doRequest("DELETE")
}

type ReposListDeploymentsCmd struct {
	baseCmd
	AntMan      bool   "name:\"ant-man-preview\" help:\"**Note:** The `transient_environment` and `production_environment` parameters are currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the [blog post](/changes/2016-04-06-deployment-and-deployment-status-enhancements) for full details.\n\nTo access the API during the preview period, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.ant-man-preview+json\n\n```\""
	Owner       string `required:"" name:"owner"`
	Repo        string `required:"" name:"repo"`
	Sha         string `name:"sha" help:"The SHA recorded at creation time."`
	Ref         string `name:"ref" help:"The name of the ref. This can be a branch, tag, or SHA."`
	Task        string "name:\"task\" help:\"The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).\""
	Environment string "name:\"environment\" help:\"The name of the environment that was deployed to (e.g., `staging` or `production`).\""
	PerPage     int64  `name:"per_page" help:"Results per page (max 100)"`
	Page        int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListDeploymentsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/deployments"
	c.updatePreview("ant-man", c.AntMan)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("sha", c.Sha)
	c.updateURLQuery("ref", c.Ref)
	c.updateURLQuery("task", c.Task)
	c.updateURLQuery("environment", c.Environment)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposGetDeploymentCmd struct {
	baseCmd
	MachineMan   bool   "name:\"machine-man-preview\" help:\"**Note:** If a deployment is created via a GitHub App, the response will include the `performed_via_github_app` object with information about the GitHub App. For more information, see the [related blog post](/changes/2016-09-14-Integrations-Early-Access).\n\nTo receive the `performed_via_github_app` object is the response, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.machine-man-preview\n\n```\""
	AntMan       bool   "name:\"ant-man-preview\" help:\"**Note:** The `transient_environment` and `production_environment` parameters are currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the [blog post](/changes/2016-04-06-deployment-and-deployment-status-enhancements) for full details.\n\nTo access the API during the preview period, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.ant-man-preview+json\n\n```\""
	Owner        string `required:"" name:"owner"`
	Repo         string `required:"" name:"repo"`
	DeploymentId int64  `required:"" name:"deployment_id"`
}

func (c *ReposGetDeploymentCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/deployments/:deployment_id"
	c.updatePreview("machine-man", c.MachineMan)
	c.updatePreview("ant-man", c.AntMan)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("deployment_id", c.DeploymentId)
	return c.doRequest("GET")
}

type ReposCreateDeploymentCmd struct {
	baseCmd
	AntMan                bool     "name:\"ant-man-preview\" help:\"**Note:** The `transient_environment` and `production_environment` parameters are currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the [blog post](/changes/2016-04-06-deployment-and-deployment-status-enhancements) for full details.\n\nTo access the API during the preview period, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.ant-man-preview+json\n\n```\""
	Owner                 string   `required:"" name:"owner"`
	Repo                  string   `required:"" name:"repo"`
	Ref                   string   `required:"" name:"ref" help:"The ref to deploy. This can be a branch, tag, or SHA."`
	Task                  string   "name:\"task\" help:\"Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).\""
	AutoMerge             bool     `name:"auto_merge" help:"Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch."`
	RequiredContexts      []string `name:"required_contexts" help:"The [status](https://developer.github.com/v3/repos/statuses/) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts."`
	Payload               string   `name:"payload" help:"JSON payload with extra information about the deployment."`
	Environment           string   "name:\"environment\" help:\"Name for the target deployment environment (e.g., `production`, `staging`, `qa`).\""
	Description           string   `name:"description" help:"Short description of the deployment."`
	TransientEnvironment  bool     "name:\"transient_environment\" help:\"Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`  \n**Note:** This parameter requires you to use the [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments) custom media type. **Note:** This parameter requires you to use the [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments) custom media type.\""
	ProductionEnvironment bool     "name:\"production_environment\" help:\"Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.  \n**Note:** This parameter requires you to use the [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments) custom media type.  \""
}

func (c *ReposCreateDeploymentCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/deployments"
	c.updatePreview("ant-man", c.AntMan)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateBody("ref", c.Ref)
	c.updateBody("task", c.Task)
	c.updateBody("auto_merge", c.AutoMerge)
	c.updateBody("required_contexts", c.RequiredContexts)
	c.updateBody("payload", c.Payload)
	c.updateBody("environment", c.Environment)
	c.updateBody("description", c.Description)
	c.updateBody("transient_environment", c.TransientEnvironment)
	c.updateBody("production_environment", c.ProductionEnvironment)
	return c.doRequest("POST")
}

type ReposListDeploymentStatusesCmd struct {
	baseCmd
	Flash        bool   "name:\"flash-preview\" help:\"**Note:** New features in the Deployments API on GitHub are currently available during a public beta. Please see the [blog post](/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/) for full details.\n\nTo access the new `environment` parameter, the two new values for the `state` parameter (`in_progress` and `queued`), and use `auto_inactive` on production deployments during the public beta period, you must provide the following custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.flash-preview+json\n\n```\""
	AntMan       bool   "name:\"ant-man-preview\" help:\"**Note:** The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive` parameters are currently available for developers to preview. Please see the [blog post](/changes/2016-04-06-deployment-and-deployment-status-enhancements) for full details.\n\nTo access the API during the preview period, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.ant-man-preview+json\n\n```\""
	Owner        string `required:"" name:"owner"`
	Repo         string `required:"" name:"repo"`
	DeploymentId int64  `required:"" name:"deployment_id"`
	PerPage      int64  `name:"per_page" help:"Results per page (max 100)"`
	Page         int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListDeploymentStatusesCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/deployments/:deployment_id/statuses"
	c.updatePreview("flash", c.Flash)
	c.updatePreview("ant-man", c.AntMan)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("deployment_id", c.DeploymentId)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposGetDeploymentStatusCmd struct {
	baseCmd
	MachineMan   bool   "name:\"machine-man-preview\" help:\"**Note:** If a deployment is created via a GitHub App, the response will include the `performed_via_github_app` object with information about the GitHub App. For more information, see the [related blog post](/changes/2016-09-14-Integrations-Early-Access).\n\nTo receive the `performed_via_github_app` object is the response, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.machine-man-preview\n\n```\""
	Flash        bool   "name:\"flash-preview\" help:\"**Note:** New features in the Deployments API on GitHub are currently available during a public beta. Please see the [blog post](/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/) for full details.\n\nTo access the new `environment` parameter, the two new values for the `state` parameter (`in_progress` and `queued`), and use `auto_inactive` on production deployments during the public beta period, you must provide the following custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.flash-preview+json\n\n```\""
	AntMan       bool   "name:\"ant-man-preview\" help:\"**Note:** The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive` parameters are currently available for developers to preview. Please see the [blog post](/changes/2016-04-06-deployment-and-deployment-status-enhancements) for full details.\n\nTo access the API during the preview period, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.ant-man-preview+json\n\n```\""
	Owner        string `required:"" name:"owner"`
	Repo         string `required:"" name:"repo"`
	DeploymentId int64  `required:"" name:"deployment_id"`
	StatusId     int64  `required:"" name:"status_id" help:"The deployment status ID."`
}

func (c *ReposGetDeploymentStatusCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/deployments/:deployment_id/statuses/:status_id"
	c.updatePreview("machine-man", c.MachineMan)
	c.updatePreview("flash", c.Flash)
	c.updatePreview("ant-man", c.AntMan)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("deployment_id", c.DeploymentId)
	c.updateURLPath("status_id", c.StatusId)
	return c.doRequest("GET")
}

type ReposCreateDeploymentStatusCmd struct {
	baseCmd
	Flash          bool   "name:\"flash-preview\" help:\"**Note:** New features in the Deployments API on GitHub are currently available during a public beta. Please see the [blog post](/changes/2018-10-16-deployments-environments-states-and-auto-inactive-updates/) for full details.\n\nTo access the new `environment` parameter, the two new values for the `state` parameter (`in_progress` and `queued`), and use `auto_inactive` on production deployments during the public beta period, you must provide the following custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.flash-preview+json\n\n```\""
	AntMan         bool   "name:\"ant-man-preview\" help:\"**Note:** The `inactive` state and the `log_url`, `environment_url`, and `auto_inactive` parameters are currently available for developers to preview. Please see the [blog post](/changes/2016-04-06-deployment-and-deployment-status-enhancements) for full details.\n\nTo access the API during the preview period, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.ant-man-preview+json\n\n```\""
	Owner          string `required:"" name:"owner"`
	Repo           string `required:"" name:"repo"`
	DeploymentId   int64  `required:"" name:"deployment_id"`
	State          string "required:\"\" name:\"state\" help:\"The state of the status. Can be one of `error`, `failure`, `inactive`, `in_progress`, `queued` `pending`, or `success`. **Note:** To use the `inactive` state, you must provide the [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments) custom media type. To use the `in_progress` and `queued` states, you must provide the [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses) custom media type.\""
	TargetUrl      string "name:\"target_url\" help:\"The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment. **Note:** It's recommended to use the `log_url` parameter, which replaces `target_url`.\""
	LogUrl         string "name:\"log_url\" help:\"The full URL of the deployment's output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `''`  \n**Note:** This parameter requires you to use the [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments) custom media type. **Note:** This parameter requires you to use the [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments) custom media type.\""
	Description    string `name:"description" help:"A short description of the status. The maximum description length is 140 characters."`
	Environment    string "name:\"environment\" help:\"Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`. **Note:** This parameter requires you to use the [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses) custom media type.\""
	EnvironmentUrl string "name:\"environment_url\" help:\"Sets the URL for accessing your environment. Default: `''`  \n**Note:** This parameter requires you to use the [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments) custom media type. **Note:** This parameter requires you to use the [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments) custom media type.\""
	AutoInactive   bool   "name:\"auto_inactive\" help:\"Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`  \n**Note:** To add an `inactive` status to `production` environments, you must use the [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses) custom media type.  \n**Note:** This parameter requires you to use the [`application/vnd.github.ant-man-preview+json`](https://developer.github.com/v3/previews/#enhanced-deployments) custom media type. **Note:** To add an `inactive` status to `production` environments, you must use the [`application/vnd.github.flash-preview+json`](https://developer.github.com/v3/previews/#deployment-statuses) custom media type.  \""
}

func (c *ReposCreateDeploymentStatusCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/deployments/:deployment_id/statuses"
	c.updatePreview("flash", c.Flash)
	c.updatePreview("ant-man", c.AntMan)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("deployment_id", c.DeploymentId)
	c.updateBody("state", c.State)
	c.updateBody("target_url", c.TargetUrl)
	c.updateBody("log_url", c.LogUrl)
	c.updateBody("description", c.Description)
	c.updateBody("environment", c.Environment)
	c.updateBody("environment_url", c.EnvironmentUrl)
	c.updateBody("auto_inactive", c.AutoInactive)
	return c.doRequest("POST")
}

type ReposListDownloadsCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListDownloadsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/downloads"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposGetDownloadCmd struct {
	baseCmd
	Owner      string `required:"" name:"owner"`
	Repo       string `required:"" name:"repo"`
	DownloadId int64  `required:"" name:"download_id"`
}

func (c *ReposGetDownloadCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/downloads/:download_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("download_id", c.DownloadId)
	return c.doRequest("GET")
}

type ReposDeleteDownloadCmd struct {
	baseCmd
	Owner      string `required:"" name:"owner"`
	Repo       string `required:"" name:"repo"`
	DownloadId int64  `required:"" name:"download_id"`
}

func (c *ReposDeleteDownloadCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/downloads/:download_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("download_id", c.DownloadId)
	return c.doRequest("DELETE")
}

type ReposListForksCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	Sort    string "name:\"sort\" help:\"The sort order. Can be either `newest`, `oldest`, or `stargazers`.\""
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListForksCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/forks"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("sort", c.Sort)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposCreateForkCmd struct {
	baseCmd
	Owner        string `required:"" name:"owner"`
	Repo         string `required:"" name:"repo"`
	Organization string `name:"organization" help:"Optional parameter to specify the organization name if forking into an organization."`
}

func (c *ReposCreateForkCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/forks"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateBody("organization", c.Organization)
	return c.doRequest("POST")
}

type ReposListInvitationsCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListInvitationsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/invitations"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposDeleteInvitationCmd struct {
	baseCmd
	Owner        string `required:"" name:"owner"`
	Repo         string `required:"" name:"repo"`
	InvitationId int64  `required:"" name:"invitation_id"`
}

func (c *ReposDeleteInvitationCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/invitations/:invitation_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("invitation_id", c.InvitationId)
	return c.doRequest("DELETE")
}

type ReposUpdateInvitationCmd struct {
	baseCmd
	Owner        string `required:"" name:"owner"`
	Repo         string `required:"" name:"repo"`
	InvitationId int64  `required:"" name:"invitation_id"`
	Permissions  string "name:\"permissions\" help:\"The permissions that the associated user will have on the repository. Valid values are `read`, `write`, and `admin`.\""
}

func (c *ReposUpdateInvitationCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/invitations/:invitation_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("invitation_id", c.InvitationId)
	c.updateBody("permissions", c.Permissions)
	return c.doRequest("PATCH")
}

type ReposListInvitationsForAuthenticatedUserCmd struct {
	baseCmd
	PerPage int64 `name:"per_page" help:"Results per page (max 100)"`
	Page    int64 `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListInvitationsForAuthenticatedUserCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/user/repository_invitations"
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposAcceptInvitationCmd struct {
	baseCmd
	InvitationId int64 `required:"" name:"invitation_id"`
}

func (c *ReposAcceptInvitationCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/user/repository_invitations/:invitation_id"
	c.updateURLPath("invitation_id", c.InvitationId)
	return c.doRequest("PATCH")
}

type ReposDeclineInvitationCmd struct {
	baseCmd
	InvitationId int64 `required:"" name:"invitation_id"`
}

func (c *ReposDeclineInvitationCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/user/repository_invitations/:invitation_id"
	c.updateURLPath("invitation_id", c.InvitationId)
	return c.doRequest("DELETE")
}

type ReposMergeCmd struct {
	baseCmd
	Owner         string `required:"" name:"owner"`
	Repo          string `required:"" name:"repo"`
	Base          string `required:"" name:"base" help:"The name of the base branch that the head will be merged into."`
	Head          string `required:"" name:"head" help:"The head to merge. This can be a branch name or a commit SHA1."`
	CommitMessage string `name:"commit_message" help:"Commit message to use for the merge commit. If omitted, a default message will be used."`
}

func (c *ReposMergeCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/merges"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateBody("base", c.Base)
	c.updateBody("head", c.Head)
	c.updateBody("commit_message", c.CommitMessage)
	return c.doRequest("POST")
}

type ReposGetPagesCmd struct {
	baseCmd
	MisterFantastic bool   "name:\"mister-fantastic-preview\" required:\"\" help:\"**Note:** The GitHub Pages API on GitHub is currently available for developers to preview. To access the API, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.mister-fantastic-preview+json\n\n```\""
	Owner           string `required:"" name:"owner"`
	Repo            string `required:"" name:"repo"`
}

func (c *ReposGetPagesCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/pages"
	c.updatePreview("mister-fantastic", c.MisterFantastic)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposUpdateInformationAboutPagesSiteCmd struct {
	baseCmd
	MisterFantastic bool   "name:\"mister-fantastic-preview\" required:\"\" help:\"**Note:** The GitHub Pages API on GitHub is currently available for developers to preview. To access the API, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\napplication/vnd.github.mister-fantastic-preview+json\n\n```\""
	Owner           string `required:"" name:"owner"`
	Repo            string `required:"" name:"repo"`
	Cname           string "name:\"cname\" help:\"Specify a custom domain for the repository. Sending a `null` value will remove the custom domain. For more about custom domains, see '[Using a custom domain with GitHub Pages](https://help.github.com/articles/using-a-custom-domain-with-github-pages/).'\""
	Source          string "name:\"source\" help:\"Update the source for the repository. Must include the branch name, and may optionally specify the subdirectory `/docs`. Possible values are `'gh-pages'`, `'master'`, and `'master /docs'`.\""
}

func (c *ReposUpdateInformationAboutPagesSiteCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/pages"
	c.updatePreview("mister-fantastic", c.MisterFantastic)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateBody("cname", c.Cname)
	c.updateBody("source", c.Source)
	return c.doRequest("PUT")
}

type ReposRequestPageBuildCmd struct {
	baseCmd
	MisterFantastic bool   "name:\"mister-fantastic-preview\" required:\"\" help:\"This endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice.\n\nTo access this endpoint during the preview period, you must provide a custom [media type](/v3/media) in the `Accept` header:\n\n```\n  application/vnd.github.mister-fantastic-preview+json\n\n```\""
	Owner           string `required:"" name:"owner"`
	Repo            string `required:"" name:"repo"`
}

func (c *ReposRequestPageBuildCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/pages/builds"
	c.updatePreview("mister-fantastic", c.MisterFantastic)
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("POST")
}

type ReposListPagesBuildsCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListPagesBuildsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/pages/builds"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposGetLatestPagesBuildCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposGetLatestPagesBuildCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/pages/builds/latest"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposGetPagesBuildCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	BuildId int64  `required:"" name:"build_id"`
}

func (c *ReposGetPagesBuildCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/pages/builds/:build_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("build_id", c.BuildId)
	return c.doRequest("GET")
}

type ReposListReleasesCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListReleasesCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/releases"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposGetReleaseCmd struct {
	baseCmd
	Owner     string `required:"" name:"owner"`
	Repo      string `required:"" name:"repo"`
	ReleaseId int64  `required:"" name:"release_id"`
}

func (c *ReposGetReleaseCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/releases/:release_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("release_id", c.ReleaseId)
	return c.doRequest("GET")
}

type ReposGetLatestReleaseCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposGetLatestReleaseCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/releases/latest"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposGetReleaseByTagCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
	Tag   string `required:"" name:"tag"`
}

func (c *ReposGetReleaseByTagCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/releases/tags/:tag"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("tag", c.Tag)
	return c.doRequest("GET")
}

type ReposCreateReleaseCmd struct {
	baseCmd
	Owner           string `required:"" name:"owner"`
	Repo            string `required:"" name:"repo"`
	TagName         string `required:"" name:"tag_name" help:"The name of the tag."`
	TargetCommitish string `name:"target_commitish" help:"Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists."`
	Name            string `name:"name" help:"The name of the release."`
	Body            string `name:"body" help:"Text describing the contents of the tag."`
	Draft           bool   "name:\"draft\" help:\"`true` to create a draft (unpublished) release, `false` to create a published one.\""
	Prerelease      bool   "name:\"prerelease\" help:\"`true` to identify the release as a prerelease. `false` to identify the release as a full release.\""
}

func (c *ReposCreateReleaseCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/releases"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateBody("tag_name", c.TagName)
	c.updateBody("target_commitish", c.TargetCommitish)
	c.updateBody("name", c.Name)
	c.updateBody("body", c.Body)
	c.updateBody("draft", c.Draft)
	c.updateBody("prerelease", c.Prerelease)
	return c.doRequest("POST")
}

type ReposEditReleaseCmd struct {
	baseCmd
	Owner           string `required:"" name:"owner"`
	Repo            string `required:"" name:"repo"`
	ReleaseId       int64  `required:"" name:"release_id"`
	TagName         string `name:"tag_name" help:"The name of the tag."`
	TargetCommitish string `name:"target_commitish" help:"Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists."`
	Name            string `name:"name" help:"The name of the release."`
	Body            string `name:"body" help:"Text describing the contents of the tag."`
	Draft           bool   "name:\"draft\" help:\"`true` makes the release a draft, and `false` publishes the release.\""
	Prerelease      bool   "name:\"prerelease\" help:\"`true` to identify the release as a prerelease, `false` to identify the release as a full release.\""
}

func (c *ReposEditReleaseCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/releases/:release_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("release_id", c.ReleaseId)
	c.updateBody("tag_name", c.TagName)
	c.updateBody("target_commitish", c.TargetCommitish)
	c.updateBody("name", c.Name)
	c.updateBody("body", c.Body)
	c.updateBody("draft", c.Draft)
	c.updateBody("prerelease", c.Prerelease)
	return c.doRequest("PATCH")
}

type ReposDeleteReleaseCmd struct {
	baseCmd
	Owner     string `required:"" name:"owner"`
	Repo      string `required:"" name:"repo"`
	ReleaseId int64  `required:"" name:"release_id"`
}

func (c *ReposDeleteReleaseCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/releases/:release_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("release_id", c.ReleaseId)
	return c.doRequest("DELETE")
}

type ReposListAssetsForReleaseCmd struct {
	baseCmd
	Owner     string `required:"" name:"owner"`
	Repo      string `required:"" name:"repo"`
	ReleaseId int64  `required:"" name:"release_id"`
	PerPage   int64  `name:"per_page" help:"Results per page (max 100)"`
	Page      int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListAssetsForReleaseCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/releases/:release_id/assets"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("release_id", c.ReleaseId)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposGetReleaseAssetCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	AssetId int64  `required:"" name:"asset_id"`
}

func (c *ReposGetReleaseAssetCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/releases/assets/:asset_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("asset_id", c.AssetId)
	return c.doRequest("GET")
}

type ReposEditReleaseAssetCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	AssetId int64  `required:"" name:"asset_id"`
	Name    string `name:"name" help:"The file name of the asset."`
	Label   string `name:"label" help:"An alternate short description of the asset. Used in place of the filename."`
}

func (c *ReposEditReleaseAssetCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/releases/assets/:asset_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("asset_id", c.AssetId)
	c.updateBody("name", c.Name)
	c.updateBody("label", c.Label)
	return c.doRequest("PATCH")
}

type ReposDeleteReleaseAssetCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	AssetId int64  `required:"" name:"asset_id"`
}

func (c *ReposDeleteReleaseAssetCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/releases/assets/:asset_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("asset_id", c.AssetId)
	return c.doRequest("DELETE")
}

type ReposGetContributorsStatsCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposGetContributorsStatsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/stats/contributors"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposGetCommitActivityStatsCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposGetCommitActivityStatsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/stats/commit_activity"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposGetCodeFrequencyStatsCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposGetCodeFrequencyStatsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/stats/code_frequency"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposGetParticipationStatsCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposGetParticipationStatsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/stats/participation"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposGetPunchCardStatsCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposGetPunchCardStatsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/stats/punch_card"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposCreateStatusCmd struct {
	baseCmd
	Owner       string `required:"" name:"owner"`
	Repo        string `required:"" name:"repo"`
	Sha         string `required:"" name:"sha"`
	State       string "required:\"\" name:\"state\" help:\"The state of the status. Can be one of `error`, `failure`, `pending`, or `success`.\""
	TargetUrl   string "name:\"target_url\" help:\"The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.  \nFor example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:  \n`http://ci.example.com/user/repo/build/sha`\""
	Description string `name:"description" help:"A short description of the status."`
	Context     string `name:"context" help:"A string label to differentiate this status from the status of other systems."`
}

func (c *ReposCreateStatusCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/statuses/:sha"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("sha", c.Sha)
	c.updateBody("state", c.State)
	c.updateBody("target_url", c.TargetUrl)
	c.updateBody("description", c.Description)
	c.updateBody("context", c.Context)
	return c.doRequest("POST")
}

type ReposListStatusesForRefCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	Ref     string `required:"" name:"ref"`
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListStatusesForRefCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/commits/:ref/statuses"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("ref", c.Ref)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposGetCombinedStatusForRefCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
	Ref   string `required:"" name:"ref"`
}

func (c *ReposGetCombinedStatusForRefCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/commits/:ref/status"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("ref", c.Ref)
	return c.doRequest("GET")
}

type ReposGetTopReferrersCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposGetTopReferrersCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/traffic/popular/referrers"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposGetTopPathsCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
}

func (c *ReposGetTopPathsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/traffic/popular/paths"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	return c.doRequest("GET")
}

type ReposGetViewsCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
	Per   string "name:\"per\" help:\"Must be one of: `day`, `week`.\""
}

func (c *ReposGetViewsCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/traffic/views"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("per", c.Per)
	return c.doRequest("GET")
}

type ReposGetClonesCmd struct {
	baseCmd
	Owner string `required:"" name:"owner"`
	Repo  string `required:"" name:"repo"`
	Per   string "name:\"per\" help:\"Must be one of: `day`, `week`.\""
}

func (c *ReposGetClonesCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/traffic/clones"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("per", c.Per)
	return c.doRequest("GET")
}

type ReposListHooksCmd struct {
	baseCmd
	Owner   string `required:"" name:"owner"`
	Repo    string `required:"" name:"repo"`
	PerPage int64  `name:"per_page" help:"Results per page (max 100)"`
	Page    int64  `name:"page" help:"Page number of the results to fetch."`
}

func (c *ReposListHooksCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/hooks"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLQuery("per_page", c.PerPage)
	c.updateURLQuery("page", c.Page)
	return c.doRequest("GET")
}

type ReposGetHookCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	HookId int64  `required:"" name:"hook_id"`
}

func (c *ReposGetHookCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/hooks/:hook_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("hook_id", c.HookId)
	return c.doRequest("GET")
}

type ReposTestPushHookCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	HookId int64  `required:"" name:"hook_id"`
}

func (c *ReposTestPushHookCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/hooks/:hook_id/tests"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("hook_id", c.HookId)
	return c.doRequest("POST")
}

type ReposPingHookCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	HookId int64  `required:"" name:"hook_id"`
}

func (c *ReposPingHookCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/hooks/:hook_id/pings"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("hook_id", c.HookId)
	return c.doRequest("POST")
}

type ReposDeleteHookCmd struct {
	baseCmd
	Owner  string `required:"" name:"owner"`
	Repo   string `required:"" name:"repo"`
	HookId int64  `required:"" name:"hook_id"`
}

func (c *ReposDeleteHookCmd) Run(isValueSetMap map[string]bool) error {
	c.isValueSetMap = isValueSetMap
	c.url.Path = "/repos/:owner/:repo/hooks/:hook_id"
	c.updateURLPath("owner", c.Owner)
	c.updateURLPath("repo", c.Repo)
	c.updateURLPath("hook_id", c.HookId)
	return c.doRequest("DELETE")
}
